const express = require('express');
const passport = require('passport');
const { body, validationResult } = require('express-validator');
const db = require('../config/database');
const router = express.Router();

// Middleware to authenticate JWT
const authenticateJWT = passport.authenticate('jwt', { session: false });

// Get all services (public endpoint) - with featured/premium prioritization
router.get('/', async (req, res) => {
  try {
    const { category, location, minPrice, maxPrice, page = 1, limit = 10 } = req.query;
    
    let query = `
      SELECT s.*, sp.business_name, sp.rating as provider_rating, sp.location as provider_location,
             u.first_name, u.last_name
      FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      JOIN users u ON sp.user_id = u.id
      WHERE s.is_active = true
    `;
    
    const queryParams = [];
    let paramCount = 0;

    if (category) {
      paramCount++;
      query += ` AND s.category ILIKE $${paramCount}`;
      queryParams.push(`%${category}%`);
    }

    if (location) {
      paramCount++;
      query += ` AND (s.location ILIKE $${paramCount} OR sp.location ILIKE $${paramCount})`;
      queryParams.push(`%${location}%`);
    }

    if (minPrice) {
      paramCount++;
      query += ` AND s.price >= $${paramCount}`;
      queryParams.push(parseFloat(minPrice));
    }

    if (maxPrice) {
      paramCount++;
      query += ` AND s.price <= $${paramCount}`;
      queryParams.push(parseFloat(maxPrice));
    }

    query += ` ORDER BY 
      sp.rating DESC,
      sp.total_bookings DESC,
      s.created_at DESC`;

    // Add pagination
    const offset = (page - 1) * limit;
    paramCount++;
    query += ` LIMIT $${paramCount}`;
    queryParams.push(parseInt(limit));
    
    paramCount++;
    query += ` OFFSET $${paramCount}`;
    queryParams.push(offset);

    const result = await db.query(query, queryParams);

    // Get total count for pagination
    let countQuery = `
      SELECT COUNT(*) as total
      FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      WHERE s.is_active = true
    `;
    
    const countParams = [];
    let countParamCount = 0;

    if (category) {
      countParamCount++;
      countQuery += ` AND s.category ILIKE $${countParamCount}`;
      countParams.push(`%${category}%`);
    }

    if (location) {
      countParamCount++;
      countQuery += ` AND (s.location ILIKE $${countParamCount} OR sp.location ILIKE $${countParamCount})`;
      countParams.push(`%${location}%`);
    }

    if (minPrice) {
      countParamCount++;
      countQuery += ` AND s.price >= $${countParamCount}`;
      countParams.push(parseFloat(minPrice));
    }

    if (maxPrice) {
      countParamCount++;
      countQuery += ` AND s.price <= $${countParamCount}`;
      countParams.push(parseFloat(maxPrice));
    }

    const countResult = await db.query(countQuery, countParams);
    const totalServices = parseInt(countResult.rows[0].total);

    res.json({
      success: true,
      services: result.rows.map(service => ({
        id: service.id,
        title: service.title,
        description: service.description,
        category: service.category,
        subcategory: service.subcategory,
        price: parseFloat(service.price),
        duration: service.duration,
        maxParticipants: service.max_participants,
        location: service.location,
        images: service.images || [],
        amenities: service.amenities || [],
        isFeatured: service.is_currently_featured,
        featuredPriority: service.featured_priority || 0,
        viewsCount: service.views_count || 0,
        bookingsCount: service.bookings_count || 0,
        provider: {
          businessName: service.business_name,
          rating: parseFloat(service.provider_rating) || 0,
          location: service.provider_location,
          ownerName: `${service.first_name} ${service.last_name}`,
          isPremium: service.is_premium_provider,
          featuredPriority: service.featured_priority || 0
        },
        createdAt: service.created_at
      })),
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalServices / limit),
        totalServices,
        hasNext: page * limit < totalServices,
        hasPrev: page > 1
      }
    });
  } catch (error) {
    console.error('Get services error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching services'
    });
  }
});

// Get service by ID
router.get('/:id', async (req, res) => {
  try {
    const serviceId = req.params.id;

    // Increment view count
    await db.query('UPDATE services SET views_count = views_count + 1 WHERE id = $1', [serviceId]);

    const result = await db.query(`
      SELECT s.*, sp.business_name, sp.rating as provider_rating, sp.location as provider_location,
             sp.description as provider_description, sp.premium_until, u.first_name, u.last_name, u.email,
             CASE 
               WHEN s.is_featured = true AND s.featured_until > NOW() THEN true 
               ELSE false 
             END as is_currently_featured,
             CASE 
               WHEN sp.premium_until > NOW() THEN true 
               ELSE false 
             END as is_premium_provider
      FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      JOIN users u ON sp.user_id = u.id
      WHERE s.id = $1 AND s.is_active = true
    `, [serviceId]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Service not found'
      });
    }

    const service = result.rows[0];

    // Get reviews for this service
    const reviewsResult = await db.query(`
      SELECT r.*, u.first_name, u.last_name
      FROM reviews r
      JOIN users u ON r.traveler_id = u.id
      WHERE r.service_id = $1
      ORDER BY r.created_at DESC
      LIMIT 10
    `, [serviceId]);

    res.json({
      success: true,
      service: {
        id: service.id,
        title: service.title,
        description: service.description,
        category: service.category,
        subcategory: service.subcategory,
        price: parseFloat(service.price),
        duration: service.duration,
        maxParticipants: service.max_participants,
        location: service.location,
        images: service.images || [],
        amenities: service.amenities || [],
        provider: {
          businessName: service.business_name,
          rating: parseFloat(service.provider_rating) || 0,
          location: service.provider_location,
          description: service.provider_description,
          ownerName: `${service.first_name} ${service.last_name}`,
          email: service.email
        },
        reviews: reviewsResult.rows.map(review => ({
          id: review.id,
          rating: review.rating,
          comment: review.comment,
          travelerName: `${review.first_name} ${review.last_name}`,
          createdAt: review.created_at
        })),
        createdAt: service.created_at
      }
    });
  } catch (error) {
    console.error('Get service error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching service'
    });
  }
});

// Get services by provider (requires authentication)
router.get('/provider/my-services', authenticateJWT, async (req, res) => {
  try {
    const userId = req.user.id;

    if (req.user.user_type !== 'service_provider') {
      return res.status(403).json({
        success: false,
        message: 'Only service providers can access this endpoint'
      });
    }

    // Get provider ID
    const providerResult = await db.query('SELECT id FROM service_providers WHERE user_id = $1', [userId]);
    if (providerResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Service provider profile not found'
      });
    }

    const providerId = providerResult.rows[0].id;

    // Get all services for this provider
    const result = await db.query(`
      SELECT s.*, 
             COUNT(b.id) as total_bookings,
             AVG(r.rating) as average_rating
      FROM services s
      LEFT JOIN bookings b ON s.id = b.service_id
      LEFT JOIN reviews r ON s.id = r.service_id
      WHERE s.provider_id = $1
      GROUP BY s.id
      ORDER BY s.created_at DESC
    `, [providerId]);

    res.json({
      success: true,
      services: result.rows.map(service => ({
        id: service.id,
        title: service.title,
        description: service.description,
        category: service.category,
        subcategory: service.subcategory,
        price: parseFloat(service.price),
        duration: service.duration,
        maxParticipants: service.max_participants,
        location: service.location,
        images: service.images || [],
        amenities: service.amenities || [],
        isActive: service.is_active,
        totalBookings: parseInt(service.total_bookings) || 0,
        averageRating: parseFloat(service.average_rating) || 0,
        createdAt: service.created_at,
        updatedAt: service.updated_at
      }))
    });
  } catch (error) {
    console.error('Get provider services error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching provider services'
    });
  }
});

// Create new service (service providers only)
router.post('/', [
  authenticateJWT,
  body('title').trim().isLength({ min: 1, max: 255 }),
  body('description').trim().isLength({ min: 1 }),
  body('category').trim().isLength({ min: 1 }),
  body('price').isFloat({ min: 0 }),
  body('duration').optional().isInt({ min: 1 }),
  body('maxParticipants').optional().isInt({ min: 1 }),
  body('location').trim().isLength({ min: 1 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation errors',
        errors: errors.array()
      });
    }

    const userId = req.user.id;

    console.log('🔍 Create service request - User details:', { 
      id: userId, 
      user_type: req.user.user_type,
      email: req.user.email,
      full_user: req.user 
    });

    if (req.user.user_type !== 'service_provider') {
      console.error('❌ User type mismatch:', {
        received: req.user.user_type,
        expected: 'service_provider',
        userId: userId,
        email: req.user.email
      });
      return res.status(403).json({
        success: false,
        message: 'Only service providers can create services. Please logout and login again.',
        debug: {
          userId: userId,
          userType: req.user.user_type,
          expected: 'service_provider',
          email: req.user.email
        }
      });
    }

    // Get provider ID
    const providerResult = await db.query('SELECT id FROM service_providers WHERE user_id = $1', [userId]);
    if (providerResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Service provider profile not found'
      });
    }

    const providerId = providerResult.rows[0].id;

    const {
      title,
      description,
      category,
      price,
      duration,
      maxParticipants,
      location,
      images,
      amenities
    } = req.body;

    // Create service
    const result = await db.query(`
      INSERT INTO services (provider_id, title, description, category, price, duration, max_participants, location, images, amenities)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `, [providerId, title, description, category, price, duration, maxParticipants, location, images, amenities]);

    const service = result.rows[0];

    res.status(201).json({
      success: true,
      message: 'Service created successfully',
      service: {
        id: service.id,
        title: service.title,
        description: service.description,
        category: service.category,
        price: parseFloat(service.price),
        duration: service.duration,
        maxParticipants: service.max_participants,
        location: service.location,
        images: service.images || [],
        amenities: service.amenities || [],
        isActive: service.is_active,
        createdAt: service.created_at
      }
    });
  } catch (error) {
    console.error('Create service error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while creating service'
    });
  }
});

// Update service (service providers only)
router.put('/:id', [
  authenticateJWT,
  body('title').optional().trim().isLength({ min: 1, max: 255 }),
  body('description').optional().trim().isLength({ min: 1 }),
  body('category').optional().trim().isLength({ min: 1 }),
  body('price').optional().isFloat({ min: 0 }),
  body('duration').optional().isInt({ min: 1 }),
  body('maxParticipants').optional().isInt({ min: 1 }),
  body('location').optional().trim().isLength({ min: 1 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation errors',
        errors: errors.array()
      });
    }

    const serviceId = req.params.id;
    const userId = req.user.id;

    if (req.user.user_type !== 'service_provider') {
      return res.status(403).json({
        success: false,
        message: 'Only service providers can update services'
      });
    }

    // Get provider ID and verify ownership
    const ownershipResult = await db.query(`
      SELECT s.id FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      WHERE s.id = $1 AND sp.user_id = $2
    `, [serviceId, userId]);

    if (ownershipResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Service not found or you do not have permission to update it'
      });
    }

    const {
      title,
      description,
      category,
      price,
      duration,
      maxParticipants,
      location,
      images,
      amenities,
      isActive
    } = req.body;

    // Update service
    const result = await db.query(`
      UPDATE services 
      SET title = COALESCE($1, title),
          description = COALESCE($2, description),
          category = COALESCE($3, category),
          price = COALESCE($4, price),
          duration = COALESCE($5, duration),
          max_participants = COALESCE($6, max_participants),
          location = COALESCE($7, location),
          images = COALESCE($8, images),
          amenities = COALESCE($9, amenities),
          is_active = COALESCE($10, is_active),
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $11
      RETURNING *
    `, [title, description, category, price, duration, maxParticipants, location, images, amenities, isActive, serviceId]);

    const service = result.rows[0];

    res.json({
      success: true,
      message: 'Service updated successfully',
      service: {
        id: service.id,
        title: service.title,
        description: service.description,
        category: service.category,
        price: parseFloat(service.price),
        duration: service.duration,
        maxParticipants: service.max_participants,
        location: service.location,
        images: service.images || [],
        amenities: service.amenities || [],
        isActive: service.is_active,
        updatedAt: service.updated_at
      }
    });
  } catch (error) {
    console.error('Update service error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while updating service'
    });
  }
});

// Delete service (service providers only)
router.delete('/:id', authenticateJWT, async (req, res) => {
  try {
    const serviceId = req.params.id;
    const userId = req.user.id;

    if (req.user.user_type !== 'service_provider') {
      return res.status(403).json({
        success: false,
        message: 'Only service providers can delete services'
      });
    }

    // Verify ownership and check for existing bookings
    const ownershipResult = await db.query(`
      SELECT s.id, COUNT(b.id) as booking_count
      FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      LEFT JOIN bookings b ON s.id = b.service_id AND b.status IN ('pending', 'confirmed')
      WHERE s.id = $1 AND sp.user_id = $2
      GROUP BY s.id
    `, [serviceId, userId]);

    if (ownershipResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Service not found or you do not have permission to delete it'
      });
    }

    const bookingCount = parseInt(ownershipResult.rows[0].booking_count);
    if (bookingCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete service with active bookings. Please cancel or complete all bookings first.'
      });
    }

    // Soft delete by setting is_active to false
    await db.query('UPDATE services SET is_active = false, updated_at = CURRENT_TIMESTAMP WHERE id = $1', [serviceId]);

    res.json({
      success: true,
      message: 'Service deleted successfully'
    });
  } catch (error) {
    console.error('Delete service error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while deleting service'
    });
  }
});
// Promote service (make it featured) - requires payment
router.post('/:id/promote', authenticateJWT, async (req, res) => {
  try {
    const serviceId = req.params.id;
    const { 
      promotion_type = 'featured',
      duration_days = 30, 
      location = 'homepage',
      payment_method, 
      payment_reference,
      amount
    } = req.body;
    const userId = req.user.id;

    console.log('✨ [PROMOTE SERVICE] Request:', { 
      serviceId, 
      promotion_type,
      duration_days, 
      location,
      amount,
      userId 
    });

    // Verify ownership
    const ownershipResult = await db.query(`
      SELECT s.id FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      WHERE s.id = $1 AND sp.user_id = $2
    `, [serviceId, userId]);

    if (ownershipResult.rows.length === 0) {
      return res.status(403).json({
        success: false,
        message: 'Service not found or you do not have permission to promote it'
      });
    }

    // Calculate promotion cost based on type
    let totalCost = amount || 50000; // Default TZS 50,000
    if (promotion_type === 'featured') {
      totalCost = location === 'both' ? 80000 : 50000;
    } else if (promotion_type === 'trending') {
      totalCost = 30000;
    } else if (promotion_type === 'search_boost') {
      totalCost = 20000;
    }

    // In production, integrate with payment gateway here
    // For now, we'll just record the promotion

    const featured_until = new Date();
    featured_until.setDate(featured_until.getDate() + duration_days);

    // Update service with promotion details
    await db.query(
      `UPDATE services 
       SET is_featured = true, 
           featured_until = $1, 
           featured_priority = featured_priority + 1,
           promotion_type = $2,
           promotion_location = $3,
           updated_at = CURRENT_TIMESTAMP 
       WHERE id = $4`,
      [featured_until, promotion_type, location, serviceId]
    );

    // Log the promotion transaction
    await db.query(
      `INSERT INTO service_promotions 
       (service_id, promotion_type, promotion_location, duration_days, cost, payment_method, payment_reference, started_at, expires_at) 
       VALUES ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP, $8)`,
      [serviceId, promotion_type, location, duration_days, totalCost, payment_method, payment_reference, featured_until]
    );

    console.log(`✅ Service ${serviceId} promoted successfully with ${promotion_type} on ${location}`);

    res.json({
      success: true,
      message: 'Service promoted successfully',
      promotion: {
        service_id: serviceId,
        promotion_type,
        location,
        duration_days,
        cost: totalCost,
        expires_at: featured_until
      }
    });
  } catch (error) {
    console.error('Promote service error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while promoting service'
    });
  }
});

// Get featured/promoted services for homepage slides
router.get('/featured/slides', async (req, res) => {
  try {
    const query = `
      SELECT s.*, sp.business_name, sp.rating as provider_rating,
             u.first_name, u.last_name
      FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      JOIN users u ON sp.user_id = u.id
      WHERE s.is_active = true 
        AND s.is_featured = true 
        AND s.featured_until > NOW()
        AND (s.promotion_location = 'homepage' OR s.promotion_location = 'both')
      ORDER BY s.featured_priority DESC, s.created_at DESC
      LIMIT 5
    `;

    const result = await db.query(query);

    console.log(`🎠 Featured slides: Found ${result.rows.length} promoted services for homepage`);

    res.json({
      success: true,
      slides: result.rows
    });
  } catch (error) {
    console.error('Get featured slides error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching featured services'
    });
  }
});

// Get trending promoted services for homepage
router.get('/trending', async (req, res) => {
  try {
    const query = `
      SELECT s.*, sp.business_name, sp.rating as provider_rating,
             u.first_name, u.last_name
      FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      JOIN users u ON sp.user_id = u.id
      WHERE s.is_active = true 
        AND s.is_featured = true 
        AND s.featured_until > NOW()
        AND s.promotion_type = 'trending'
        AND (s.promotion_location = 'trending_section' 
             OR s.promotion_location = 'increased_visibility' 
             OR s.promotion_location = 'search_priority')
      ORDER BY s.featured_priority DESC, s.views_count DESC, s.created_at DESC
      LIMIT 12
    `;

    const result = await db.query(query);

    console.log(`📈 Trending services: Found ${result.rows.length} promoted trending services`);

    res.json({
      success: true,
      services: result.rows
    });
  } catch (error) {
    console.error('Get trending services error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching trending services'
    });
  }
});

// Toggle service status (activate/deactivate)
router.patch('/:id/status', authenticateJWT, async (req, res) => {
  try {
    const serviceId = req.params.id;
    const userId = req.user.id;

    console.log('🔄 [ACTIVATE/DEACTIVATE] Service status toggle request:', {
      serviceId,
      userId,
      userType: req.user.user_type
    });

    if (req.user.user_type !== 'service_provider') {
      console.error('❌ User is not a service provider');
      return res.status(403).json({
        success: false,
        message: 'Only service providers can update service status'
      });
    }

    // Verify ownership
    const ownershipResult = await db.query(`
      SELECT s.id, s.is_active, s.title FROM services s
      JOIN service_providers sp ON s.provider_id = sp.id
      WHERE s.id = $1 AND sp.user_id = $2
    `, [serviceId, userId]);

    console.log('🔍 Ownership check result:', ownershipResult.rows);

    if (ownershipResult.rows.length === 0) {
      console.error('❌ Service not found or user does not have permission');
      return res.status(404).json({
        success: false,
        message: 'Service not found or you do not have permission to update it'
      });
    }

    // Toggle status
    const currentStatus = ownershipResult.rows[0].is_active;
    const newStatus = !currentStatus;
    const serviceTitle = ownershipResult.rows[0].title;

    console.log('📝 Updating status:', {
      serviceTitle,
      currentStatus,
      newStatus
    });

    await db.query(`
      UPDATE services 
      SET is_active = $1, updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
    `, [newStatus, serviceId]);

    console.log(`✅ Service "${serviceTitle}" ${newStatus ? 'activated' : 'deactivated'} successfully`);

    res.json({
      success: true,
      message: `Service ${newStatus ? 'activated' : 'deactivated'} successfully`,
      isActive: newStatus
    });
  } catch (error) {
    console.error('Toggle service status error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while updating service status'
    });
  }
});

module.exports = router;
